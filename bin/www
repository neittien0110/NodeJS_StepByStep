#!/usr/bin/env node
/** 
 * @fileoverview  là điểm bắt đầu, entry point của website
*/

/**
 * Khai báo sử dụng các module cần thiết
 */

 /** entry point thực sự với các tính năng được khai báo và thực thi ở đây */
var app = require('../app');
/** Triệu gọi module debug:  hiển thị thêm tên của module trong dòng log; tô màu các thông báo, mã lỗi;
 *  @param param2 Tham số thứ 2 là tên gợi nhớ  (thường là tên module) sẽ hiển thị đầu tiên của dòng thông báo.
 *                Và khi đó để hiển thị được thông báo, trước khi chạy node, phải thiết lập biến môi trường DEBUG
 *                > SET DEBUG=www  & node bin/www
 *  @see https://www.npmjs.com/package/debug
*/
var debug = require('debug')('www');
var http = require('http');
var express = require('express');
debug('Dịch vụ lắng nghe ở cổng  %o', process.env.PORT);

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
    //-----------TRỞ THÀNH WEB lai TĨNH ------------------
//Module quản lý truy cập vào web tĩnh ở một thư mục nào đó
var serveStatic = require('serve-static') 
//Chỉ định rõ thư mục chứa các trang html tĩnh và các file tĩnh mặc định
var staticCallback = serveStatic('public/help',{ 'index': ['index.html', 'index.htm'] });

    /**
     * Tạo đối tượng HTTP server với hàm đáp ứng reponse là staticCallback
     */
    //var server = http.createServer(app);
    var serverDomain2 = http.createServer(staticCallback);  // server phục vụ riêng cho domain 2, sẽ được nhượng quyền quản lý bởi server chung
    var server = express();                                  // server chung của mọi domain, kiêm xử lý luôn domain 1

    var vhost = require('vhost');       //phân giải theo domain

    // Đặt virtual host trước thì sẽ ưu tiên thực hiện trước
    // Cách 1: server chung sẽ xử lý toàn bộ các URL ở các domain
    server.use(vhost('example1.com', function (req, res) {
      // handle req + res belonging to mail.example.com
      res.setHeader('Content-Type', 'text/plain')
      res.end('hello from example1.com!');
      debug("example1.com này");
    }));
    
    // Cách 2: server chung sẽ xử lý chỉ bắt domain, rồi nhường quyền quản trị cho server riêng. Rõ ràng và kế thừa tốt. Nên làm
    server.use(vhost('example2.com', function (req, res) {
      // nhượng quyền quản lý cho server khác thụ lý tiếp
      serverDomain2.emit('request', req, res)
      debug("example2.com này");
    }))


    //server.use('/stat', staticCallback);       //http://localhost:3000/stat  sẽ hiện ra các website tĩnh
    // sẽ không còn tác dụng vì hàm callback  server.use(vhost('example1.com'..) đã hứng hết sự kiện rồi
    server.use('/stat', serveStatic('public/help2',{ 'extensions': ['html', 'htm'] }));  //http://localhost:3000/stat/xyz   sẽ hiện ra trang tĩnh xyz.html  trong thư mục tương ứng thứ 2
    
    // sẽ không còn tác dụng vì hàm callback  server.use(vhost('example1.com'..) đã hứng hết sự kiện rồi
    server.get('/code', (req,res) => {
      res.send('Trang chủ. Page in Code');
    });

    server.get('/', (req,res) => {
      app(req,res)
    });



/** Bắt đầu lắng nghe dich vụ. Mặc định trên tất cả các interface mạng. */
server.listen(port);

/** Khai báo hàm callback khi có lỗi xảy ra */
server.on('error', onError);
/** Khai báo hàm callback khi có tạo listerning port */
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Hàm sự kiện xảy ra khi HTTP server ghi nhận có lỗi
 * @param error   in/out  đối tượng quản lý HTTP error
 */
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Hàm sự kiện xảy ra khi HTTP server tạo ra cổng dịch vụ lắng nghe
 */
function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Dịch vụ đang lắng nghe trên cổng ' + bind);
}
